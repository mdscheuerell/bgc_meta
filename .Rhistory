<<<<<<< HEAD
## estimated parameters for unbiased RW
fit_brw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## compare AIC (biased RW is lower)
AIC(fit_rw, fit_brw)
## get bias estimate
u_hat <- coef(fit_brw)$U
## bootstrap bias estimate
boots <- MARSS::MARSSparamCIs(fit_brw, nboot = 1000)
## 95% CI
c(boots$par.lowCI$U, boots$par.upCI$U)
## Is there a trend via Mann-Kendall? Yes
trend::mk.test(yb)
## estimate trend via Sen's method
sen_fit <- trend::sens.slope(yb)
sen_int <- median(yb - sen_fit$estimates * seq(nn))
y_hat <- sen_fit$estimates * seq(nn) + sen_int
sen_resid <- yb - y_hat
## estimate trend via lm()
# fit_lm <- lm(yb ~ seq(nn))
# summary(fit_lm)
# y_hat <- fitted(fit_lm)
# confint(fit_lm)
## plots of fits, residuals, and ACF
pdf("biased_rw_ex.pdf", width = 7, height = 5)
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(t(residuals(fit_brw)$model), lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(t(residuals(fit_brw)$model), las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm fit
# plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
#         ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
# text(x = 0, y = 12, expression(paste(hat(b), " = 0.43 (0.38, 0.48)")), pos = 4, cex = 0.8)
# lines(y_hat, col = "indianred", lwd = 2)
# mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm residuals
# plot.ts(residuals(fit_lm), lwd = 2, las = 1, col = "indianred",
#         ylim = range(residuals(fit_lm)), ylab = "Residuals")
# mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm ACF
# acf(residuals(fit_lm), las = 1, lag.max = 10,
#     xlim = c(1,10), ylim = c(-0.6, 0.6))
# mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
dev.off()
install.packages("extraDistr")
## sample size
nn <- 30
## positive bias
uu <- 0.3
## process SD
sigma_p <- 0.8
## obs SD
sigma_o <- 0.6
## generate process & obs errors
set.seed(1)
## process errors
ww <- rnorm(nn, 0, sigma_p)
## obs errors
vv <- rnorm(nn, 0, sigma_o)
## unbiased RW
xu <- cumsum(ww)
## biased RW
xb <- cumsum(ww + uu)
plot.ts(cbind(xu, xb))
## unbiasd RW with obs error
yu <- xu + vv
## biased RW with obs error
yb <- xb + vv
plot.ts(cbind(yu, yb))
## estimate bias with MARSS
## model defn for unbiased RW
mod_list <- list(
B = matrix(1),
U = matrix(0),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r")
)
## estimated parameters for unbiased RW
fit_rw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## update model defn for biased RW
mod_list$U <- matrix("bias")
## estimated parameters for unbiased RW
fit_brw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## compare AIC (biased RW is lower)
AIC(fit_rw, fit_brw)
## get bias estimate
u_hat <- coef(fit_brw)$U
## bootstrap bias estimate
boots <- MARSS::MARSSparamCIs(fit_brw, nboot = 1000)
## 95% CI
c(boots$par.lowCI$U, boots$par.upCI$U)
## Is there a trend via Mann-Kendall? Yes
trend::mk.test(yb)
## estimate trend via Sen's method
sen_fit <- trend::sens.slope(yb)
sen_int <- median(yb - sen_fit$estimates * seq(nn))
y_hat <- sen_fit$estimates * seq(nn) + sen_int
sen_resid <- yb - y_hat
## estimate trend via lm()
# fit_lm <- lm(yb ~ seq(nn))
# summary(fit_lm)
# y_hat <- fitted(fit_lm)
# confint(fit_lm)
## plots of fits, residuals, and ACF
pdf("biased_rw_ex.pdf", width = 7, height = 5)
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(t(residuals(fit_brw)$model), lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(t(residuals(fit_brw)$model), las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm fit
# plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
#         ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
# text(x = 0, y = 12, expression(paste(hat(b), " = 0.43 (0.38, 0.48)")), pos = 4, cex = 0.8)
# lines(y_hat, col = "indianred", lwd = 2)
# mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm residuals
# plot.ts(residuals(fit_lm), lwd = 2, las = 1, col = "indianred",
#         ylim = range(residuals(fit_lm)), ylab = "Residuals")
# mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm ACF
# acf(residuals(fit_lm), las = 1, lag.max = 10,
#     xlim = c(1,10), ylim = c(-0.6, 0.6))
# mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
dev.off()
## sample size
nn <- 30
## positive bias
uu <- 0.3
## process SD
sigma_p <- 0.8
## obs SD
sigma_o <- 0.6
## generate process & obs errors
set.seed(1)
## process errors
ww <- rnorm(nn, 0, sigma_p)
## obs errors
vv <- rnorm(nn, 0, sigma_o)
## unbiased RW
xu <- cumsum(ww)
## biased RW
xb <- cumsum(ww + uu)
plot.ts(cbind(xu, xb))
## unbiasd RW with obs error
yu <- xu + vv
## biased RW with obs error
yb <- xb + vv
plot.ts(cbind(yu, yb))
## estimate bias with MARSS
## model defn for unbiased RW
mod_list <- list(
B = matrix(1),
U = matrix(0),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r")
)
## estimated parameters for unbiased RW
fit_rw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## update model defn for biased RW
mod_list$U <- matrix("bias")
## estimated parameters for unbiased RW
fit_brw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## compare AIC (biased RW is lower)
AIC(fit_rw, fit_brw)
## get bias estimate
u_hat <- coef(fit_brw)$U
## bootstrap bias estimate
boots <- MARSS::MARSSparamCIs(fit_brw, nboot = 1000)
## 95% CI
c(boots$par.lowCI$U, boots$par.upCI$U)
## Is there a trend via Mann-Kendall? Yes
trend::mk.test(yb)
## estimate trend via Sen's method
sen_fit <- trend::sens.slope(yb)
sen_int <- median(yb - sen_fit$estimates * seq(nn))
y_hat <- sen_fit$estimates * seq(nn) + sen_int
sen_resid <- yb - y_hat
## estimate trend via lm()
# fit_lm <- lm(yb ~ seq(nn))
# summary(fit_lm)
# y_hat <- fitted(fit_lm)
# confint(fit_lm)
## plots of fits, residuals, and ACF
pdf("biased_rw_ex.pdf", width = 7, height = 5)
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(t(residuals(fit_brw)$model), lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(t(residuals(fit_brw)$model), las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm fit
# plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
#         ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
# text(x = 0, y = 12, expression(paste(hat(b), " = 0.43 (0.38, 0.48)")), pos = 4, cex = 0.8)
# lines(y_hat, col = "indianred", lwd = 2)
# mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm residuals
# plot.ts(residuals(fit_lm), lwd = 2, las = 1, col = "indianred",
#         ylim = range(residuals(fit_lm)), ylab = "Residuals")
# mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm ACF
# acf(residuals(fit_lm), las = 1, lag.max = 10,
#     xlim = c(1,10), ylim = c(-0.6, 0.6))
# mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
dev.off()
residuals(fit_brw)
?residuals
?MARSS::residuals
?MARSS:::residuals
?MARSS
residuals(fit_brw, type = "tt1")
residuals(fit_brw, type = "tT")
fit_brw$states
diff(fit_brw$states)
diff(t(fit_brw$states))
residuals(fit_brw, type = "tt")
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
residuals(fit_brw, type = "tT")$.resids
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
residuals(fit_brw, type = "tT", clean = TRUE)$.resids
residuals(fit_brw, type = "tT", clean = TRUE)
plot.ts(cbind(yu, yb))
ww_hat <- residuals(fit_brw, type = "tT")
ww_hat <- subset(ww_hat, name=="state")
ww_hat
ww_hat <- residuals(fit_brw, type = "tT")
ww_hat <- subset(ww_hat, name=="model")
ww_hat
ww_hat <- residuals(fit_brw, type = "tT")
subset(ww_hat, name=="model")$.resids
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(ww_hat, lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(ww_hat, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
range(sen_resid)
ww_hat
ww_hat <- residuals(fit_brw, type = "tT")
ww_hat <- subset(ww_hat, name=="model")$.resids
ww_hat
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(ww_hat, lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(ww_hat, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
## example for a biased RW
## sample size
nn <- 30
## positive bias
uu <- 0.3
## process SD
sigma_p <- 0.8
## obs SD
sigma_o <- 0.6
## generate process & obs errors
set.seed(1)
## process errors
ww <- rnorm(nn, 0, sigma_p)
## obs errors
vv <- rnorm(nn, 0, sigma_o)
## unbiased RW
xu <- cumsum(ww)
## biased RW
xb <- cumsum(ww + uu)
plot.ts(cbind(xu, xb))
## unbiasd RW with obs error
yu <- xu + vv
## biased RW with obs error
yb <- xb + vv
plot.ts(cbind(yu, yb))
## estimate bias with MARSS
## model defn for unbiased RW
mod_list <- list(
B = matrix(1),
U = matrix(0),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r")
)
## estimated parameters for unbiased RW
fit_rw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## update model defn for biased RW
mod_list$U <- matrix("bias")
## estimated parameters for unbiased RW
fit_brw <- MARSS::MARSS(matrix(yb, nrow = 1), mod_list)
## compare AIC (biased RW is lower)
AIC(fit_rw, fit_brw)
## get bias estimate
u_hat <- coef(fit_brw)$U
## bootstrap bias estimate
boots <- MARSS::MARSSparamCIs(fit_brw, nboot = 1000)
## 95% CI
c(boots$par.lowCI$U, boots$par.upCI$U)
## Is there a trend via Mann-Kendall? Yes
trend::mk.test(yb)
## estimate trend via Sen's method
sen_fit <- trend::sens.slope(yb)
sen_int <- median(yb - sen_fit$estimates * seq(nn))
y_hat <- sen_fit$estimates * seq(nn) + sen_int
sen_resid <- yb - y_hat
## estimate trend via lm()
# fit_lm <- lm(yb ~ seq(nn))
# summary(fit_lm)
# y_hat <- fitted(fit_lm)
# confint(fit_lm)
ww_hat <- residuals(fit_brw, type = "tT")
ww_hat <- subset(ww_hat, name=="model")$.resids
## plots of fits, residuals, and ACF
pdf("biased_rw_ex.pdf", width = 7, height = 5)
par(mfrow = c(2,3), mai = c(0.7, 0.7, 0.1, 0.1), omi = c(0, 0, 0.2, 0))
## BRW fit
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.36 (0.10, 0.62)")), pos = 4, cex = 0.8)
lines(t(fit_brw$states), col = "dodgerblue", lwd = 2)
mtext("A", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW residuals
plot.ts(ww_hat, lwd = 2, las = 1, col = "dodgerblue",
ylim = range(sen_resid), ylab = "Residuals")
mtext("B", 3, line = 0.5, adj = 0, cex = 0.8)
## BRW ACF
acf(ww_hat, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("C", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's slope
plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
text(x = 0, y = 12.5, expression(paste(hat(b), " = 0.44 (0.39, 0.50)")), pos = 4, cex = 0.8)
lines(y_hat, col = "indianred", lwd = 2)
mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's residuals
plot.ts(sen_resid, lwd = 2, las = 1, col = "indianred",
ylim = range(sen_resid), ylab = "Residuals")
mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
## Sen's ACF
acf(sen_resid, las = 1, lag.max = 10,
xlim = c(1,10), ylim = c(-0.6, 0.6))
mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm fit
# plot.ts(yb, pch = 16, type = "o", cex = 1.2, las = 1,
#         ylim = range(cbind(y_hat, yb)), ylab = expression(italic(y)))
# text(x = 0, y = 12, expression(paste(hat(b), " = 0.43 (0.38, 0.48)")), pos = 4, cex = 0.8)
# lines(y_hat, col = "indianred", lwd = 2)
# mtext("D", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm residuals
# plot.ts(residuals(fit_lm), lwd = 2, las = 1, col = "indianred",
#         ylim = range(residuals(fit_lm)), ylab = "Residuals")
# mtext("E", 3, line = 0.5, adj = 0, cex = 0.8)
# ## lm ACF
# acf(residuals(fit_lm), las = 1, lag.max = 10,
#     xlim = c(1,10), ylim = c(-0.6, 0.6))
# mtext("F", 3, line = 0.5, adj = 0, cex = 0.8)
dev.off()
tt <- 30
nn <- 3
xx <- matrix(rnorm(TT*nn), nn, tt)
xx <- matrix(rnorm(tt*nn), nn, tt)
xx
RR <- matrix(list("c"), nn, nn)
RR
diag(RR) <- paste0("r", seq(nn))
RR
MARSS::MARSS(xx, mod_list)
mod_list <- list(
B = "identity",
U = "zero",
Q = "diagonal and equal",
Z = "identity",
A = "zero",
R = RR
)
MARSS::MARSS(xx, mod_list)
=======
pivot_longer(cols = X.NF_DOR_HP3:X.NF_TLW_C38, names_to = "WA", values_to = "NH4N")
NH4N.se <- as.data.frame(t(MarsSeasSiteState[[5]]$states.se)) %>%
mutate(TimeNum = seq(1,TimeSeriesLength, by = 1))%>%
pivot_longer(cols = X.NF_DOR_HP3:X.NF_TLW_C38, names_to = "WA", values_to = "NH4N.se")
head(as.data.frame(t(MarsSeasSiteState[[6]]$states)) )
## TDP
TDP <- as.data.frame(t(MarsSeasSiteState[[6]]$states)) %>%
mutate(TimeNum = seq(1,TimeSeriesLength, by = 1)) %>%
pivot_longer(cols = X.NF_DOR_HP3:X.NW_HJA_GSWS09, names_to = "WA", values_to = "TDP")
TDP.se <- as.data.frame(t(MarsSeasSiteState[[6]]$states.se))%>%
mutate(TimeNum = seq(1,TimeSeriesLength, by = 1))%>%
pivot_longer(cols = X.NF_DOR_HP3:X.NW_HJA_GSWS09, names_to = "WA", values_to = "TDP.se")
## Bring dataframes together ----
# "Ca"  "DOC" "NO3" "SO4" "NH4" "TDP"
states0.s <- Ca %>%
full_join(DOC, by = c("TimeNum", "WA"))%>%
full_join(NO3N, by = c("TimeNum", "WA"))%>%
full_join(SO4, by = c("TimeNum", "WA"))%>%
full_join(NH4N, by = c("TimeNum", "WA"))%>%
full_join(TDP, by = c("TimeNum", "WA")) %>%
pivot_longer(cols = Ca:TDP, names_to =  "solute", values_to = "states")
states0.se <-   Ca.se %>%
full_join(DOC.se, by = c("TimeNum", "WA"))%>%
full_join(NO3N.se, by = c("TimeNum", "WA"))%>%
full_join(SO4.se, by = c("TimeNum", "WA"))%>%
full_join(NH4N.se, by = c("TimeNum", "WA"))%>%
full_join(TDP.se, by = c("TimeNum", "WA")) %>%
pivot_longer(cols = Ca.se:TDP.se, names_to =  "solute", values_to = "states.se") %>%
mutate_at("solute", str_replace, ".se","")
states <- states0.s %>%
full_join(states0.se, by = c("TimeNum", "WA", "solute")) %>%
separate(WA, sep = "_", into= c("region", "site", "watershed")) %>%
mutate_at("region", str_replace, "X.", "") %>%
mutate_at(c("region", "site", "watershed"), factor)  %>%
full_join(BlankTS, by = "TimeNum")
head(states)
levels(states$site)
states <- states0.s %>%
full_join(states0.se, by = c("TimeNum", "WA", "solute")) %>%
separate(WA, sep = "_", into= c("region", "site", "watershed")) %>%
mutate_at("region", str_replace, "X.", "") %>%
mutate_at(c("region", "site", "watershed"), factor)  %>%
full_join(BlankTS, by = "TimeNum") %>%
mutate(Date = as.POSIXct(Date, format = "%Y-%m-%d"))
head(states)
SiteList <- states %>% select(site, watershed) %>% distinct()
SiteList
states %>% select(site, watershed, states) %>% filter(is.na(states)) %>% distinct()
states %>% select(site, watershed, states, solute) %>% filter(is.na(states)) %>% distinct()
# Make plot
SoluteList <- unique(states$solute)
SoluteList
for(i in 1:length(SoluteList)){
# SoluteList_i <- SoluteList[i]
# SoluteList_i <- SoluteList[6]
TestPlot_i <- ggplot() +
geom_line( data = states %>%
filter(solute == SoluteList[i]), aes(y = states, x = Date, color = watershed)) +
geom_ribbon(data = states %>%
filter(solute == SoluteList[i]), aes(ymin = states - states.se,
ymax = states + states.se,
x = Date, fill= watershed),
alpha = 0.25, color = "transparent") +
facet_grid(site ~., scales = "free_x") +
theme_bw() +
ylab(SoluteList[i]) +
xlab("Time") +
scale_x_datetime(date_labels = "%b-%y", date_breaks = "5 years") +
# scale_y_continuous(breaks = c(-7.5, 0, 7.5), limits = c(-7.5,7.5)) +
theme(axis.title = element_text(size = 20),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
panel.grid.minor = element_blank(),
panel.spacing = unit(1,"lines"))
print(TestPlot_i)
}
warnings()
pdf(file = file.path(here::here("plots"), "MARSS_StatePlots_20220821.pdf"), paper = "letter")
for(i in 1:length(SoluteList)){
SoluteList_i <- SoluteList[i]
# SoluteList_i <- SoluteList[6]
TestPlot_i <- ggplot() +
geom_line( data = states %>%
filter(solute == SoluteList_i), aes(y = states, x = Date, color = watershed)) +
geom_ribbon(data = states %>%
filter(solute == SoluteList_i), aes(ymin = states - states.se,
ymax = states + states.se,
x = Date, fill= watershed),
alpha = 0.25, color = "transparent") +
facet_grid(site ~., scales = "free_x") +
theme_bw() +
ylab(SoluteList_i) +
xlab("Time") +
scale_x_datetime(date_labels = "%b-%y", date_breaks = "5 years") +
# scale_y_continuous(breaks = c(-7.5, 0, 7.5), limits = c(-7.5,7.5)) +
theme(axis.title = element_text(size = 20),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
panel.grid.minor = element_blank(),
panel.spacing = unit(1,"lines"))
print(TestPlot_i)
}
dev.off()
pdf(file = file.path(here::here("plots"), "MARSS_StatePlots_20220821.pdf"), paper = "letter")
for(i in 1:length(SoluteList)){
SoluteList_i <- SoluteList[i]
# SoluteList_i <- SoluteList[6]
TestPlot_i <- ggplot() +
geom_line( data = states %>%
filter(solute == SoluteList_i), aes(y = states, x = Date, color = watershed)) +
geom_ribbon(data = states %>%
filter(solute == SoluteList_i), aes(ymin = states - states.se,
ymax = states + states.se,
x = Date, fill= watershed),
alpha = 0.25, color = "transparent") +
facet_grid(site ~., scales = "free_x") +
theme_bw() +
ylab(SoluteList_i) +
xlab("Time") +
scale_x_datetime(date_labels = "%y", date_breaks = "5 years") +
# scale_y_continuous(breaks = c(-7.5, 0, 7.5), limits = c(-7.5,7.5)) +
theme(axis.title = element_text(size = 20),
axis.text = element_text(size = 12),
strip.text = element_text(size = 12),
panel.grid.minor = element_blank(),
panel.spacing = unit(1,"lines"))
print(TestPlot_i)
}
dev.off()
pdf(file = file.path(here::here("plots"), "MARSS_StatePlots_20220821.pdf"), paper = "letter")
for(i in 1:length(SoluteList)){
SoluteList_i <- SoluteList[i]
# SoluteList_i <- SoluteList[6]
TestPlot_i <- ggplot() +
geom_line( data = states %>%
filter(solute == SoluteList_i), aes(y = states, x = Date, color = watershed)) +
geom_ribbon(data = states %>%
filter(solute == SoluteList_i), aes(ymin = states - states.se,
ymax = states + states.se,
x = Date, fill= watershed),
alpha = 0.25, color = "transparent") +
facet_grid(site ~., scales = "free_y") +
theme_bw() +
ylab(SoluteList_i) +
xlab("Time") +
scale_x_datetime(date_labels = "%Y", date_breaks = "5 years") +
# scale_y_continuous(breaks = c(-7.5, 0, 7.5), limits = c(-7.5,7.5)) +
theme(axis.title = element_text(size = 20),
axis.text = element_text(size = 12),
strip.text = element_text(size = 12),
panel.grid.minor = element_blank(),
panel.spacing = unit(1,"lines"))
print(TestPlot_i)
}
dev.off()
# Bias plot ----
# load the MARS data
MARSS_BiasCoefs <- as.data.frame(matrix(nrow = 1, ncol = 5))
names(MARSS_BiasCoefs) <- c("U", "U_lowCI", "U_upCI", "site", "solute")
head(MARSS_BiasCoefs)
# FUCTIONS TO BUILD SEASONAL DATASET
# https://stackoverflow.com/questions/24384179/how-to-determine-whether-two-variables-have-the-same-sign-in-r/24384436
SigFun <- function(a,b) {ifelse(a == 0 | b == 0,"FALSE",!xor(sign(a)+1,sign(b)+1))}
# for the models with site states
SeasDatFun.Site <- function(MarsMod, SitesList){
# for testing
# MarsMod <- MarsSeasSiteState[[1]]
Modpar <- MARSSparamCIs(MarsMod, method = "hessian", alpha = 0.05, nboot = 1000)
ModCcoefs <- data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "C.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci)) %>%
pivot_wider(id_cols = sites, names_from = seas, values_from = C:Sig) %>%
mutate(Sig = paste0(Sig_seas_1, "_", Sig_seas_2),
Sig2 = ifelse(Sig == "FALSE_FALSE", "no",
ifelse(Sig == "TRUE_FALSE" | Sig == "FALSE_TRUE", "one",
ifelse(Sig == "TRUE_TRUE", "both", "blah"))))
}
# for models with catchment (unique) states
SeasDatFun.Unique <- function(MarsMod, SitesList){
# for testing
# MarsMod <- SeasUniqState[[6]]
# SitesList <- SitesList_Not4Tdp
Modpar <- MARSSparamCIs(MarsMod, method = "hessian", alpha = 0.05, nboot = 1000)
ModCcoefs <- data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci)) %>%
pivot_wider(id_cols = region:catchment, names_from = seas, values_from = C:Sig) %>%
mutate(Sig = paste0(Sig_seas_1, "_", Sig_seas_2),
Sig2 = ifelse(Sig == "FALSE_FALSE", "no",
ifelse(Sig == "TRUE_FALSE" | Sig == "FALSE_TRUE", "one",
ifelse(Sig == "TRUE_TRUE", "both", "blah"))))
}
# FUNCTIONS TO GENERATE TIME SERIES FOR PLOTING
# for sites
seasPlotFun.Site <- function(periodS, MarsDF, solute){
# set up sin and cos matrix
# periodS <- 12# TEST
PeriodStart <- 1
PeriodEnd <- periodS
monthNum <- seq(PeriodStart, PeriodEnd, by = 1)
#seas_1 is sin; seas_2 is cos
cos.t <- cos(2 * pi * monthNum/periodS)
sin.t <- sin(2 * pi * monthNum/periodS)
#sin is seas_1, cos is seas_2
c.Four <- rbind(sin.t, cos.t) # if these get switched in C output they have to be switched
# MarsDF <- Seas.Ca # TEST
coefs <- as.matrix(MarsDF[,c("C_seas_1", "C_seas_2")])
# calculate seasonality
seas.F <- coefs %*% c.Four
seas.F.df <- as.data.frame(t(seas.F))
colnames(seas.F.df) <- MarsDF$sites
seas.F.df$month <- monthNum
# Prepare and export data frame
seas.F.df2 <- seas.F.df %>%
pivot_longer(cols = -month, names_to = "sites", values_to = "seas") %>%
left_join(MarsDF %>%
select(sites,Sig2), by = c("sites")) %>%
mutate(solute = solute)
seas.F.df2
}
# For catchments
seasPlotFun.Unique <- function(periodS, MarsDF, solute){
# set up sin and cos matrix
# periodS <- 12# TEST
PeriodStart <- 1
PeriodEnd <- periodS
monthNum <- seq(PeriodStart, PeriodEnd, by = 1)
#seas_1 is sin; seas_2 is cos
cos.t <- cos(2 * pi * monthNum/periodS)
sin.t <- sin(2 * pi * monthNum/periodS)
#sin is seas_1, cos is seas_2
c.Four <- rbind(sin.t, cos.t) # if these get switched in C output they have to be switched
# MarsDF <- Seas.SO4.Unique # TEST
coefs <- as.matrix(MarsDF[,c("C_seas_1", "C_seas_2")])
# calculate seasonality
seas.F <- coefs %*% c.Four
seas.F.df <- as.data.frame(t(seas.F))
colnames(seas.F.df) <- MarsDF$catchment
seas.F.df$month <- monthNum
# Prepare and export data frame
seas.F.df2 <- seas.F.df %>%
pivot_longer(cols = -month, names_to = "catchment", values_to = "seas") %>%
left_join(MarsDF %>%
select(catchment, sites,Sig2), by = c("catchment")) %>%
mutate(solute = solute)
seas.F.df2
}
# PREPARE DATASETS
SitesList_Not4Tdp <- levels(states$site)
SitesList_Not4Tdp
unique(states[!is.na(states$states),]$site)
unique(states[states$solute == "TDP" & !is.na(states$states),]$site)
SitesList_Ca <- unique(states[states$solute == "Ca" & !is.na(states$states),]$site)
SitesList_Ca
SitesList_DOC <- unique(states[states$solute == "DOC" & !is.na(states$states),]$site)
SitesList_DOC
SitesList_NH4 <- unique(states[states$solute == "NH4" & !is.na(states$states),]$site)
SitesList_NH4
unique(states$solute)
SitesList_NH4 <- unique(states[states$solute == "NH4N" & !is.na(states$states),]$site)
SitesList_NH4
SitesList_NO3 <- unique(states[states$solute == "NO3N" & !is.na(states$states),]$site)
SitesList_NO3
SitesList_SO4 <- unique(states[states$solute == "SO4" & !is.na(states$states),]$site)
SitesList_SO4
SitesList_Ca <- unique(states[states$solute == "TDP" & !is.na(states$states),]$site)
SitesList_TDP <- unique(states[states$solute == "TDP" & !is.na(states$states),]$site)
SitesList_TDP
SitesList_Ca <- unique(states[states$solute == "Ca" & !is.na(states$states),]$site)
SitesList_DOC <- unique(states[states$solute == "DOC" & !is.na(states$states),]$site)
SitesList_NH4 <- unique(states[states$solute == "NH4N" & !is.na(states$states),]$site)
SitesList_NO3 <- unique(states[states$solute == "NO3N" & !is.na(states$states),]$site)
SitesList_SO4 <- unique(states[states$solute == "SO4" & !is.na(states$states),]$site)
SitesList_TDP <- unique(states[states$solute == "TDP" & !is.na(states$states),]$site)
# for the ones with hessian issues I need to write a different function that uses
# MARSSparamCIs() with method = "parametric"
# That will take forever
Seas.Ca <- SeasDatFun.Unique(MarsSeasSiteState[[1]], SitesList_Ca)
# for testing
MarsMod <- SeasUniqState[[6]]
# for testing
MarsMod <- MarsSeasSiteState[[6]]
SitesList <- SitesList_TDP
Modpar <- MARSSparamCIs(MarsMod, method = "hessian", alpha = 0.05, nboot = 1000)
Modpar
ModCcoefs <- data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci)) %>%
pivot_wider(id_cols = region:catchment, names_from = seas, values_from = C:Sig) %>%
mutate(Sig = paste0(Sig_seas_1, "_", Sig_seas_2),
Sig2 = ifelse(Sig == "FALSE_FALSE", "no",
ifelse(Sig == "TRUE_FALSE" | Sig == "FALSE_TRUE", "one",
ifelse(Sig == "TRUE_TRUE", "both", "blah"))))
head(data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")))
ata.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.",""))
data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.",""))
data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_")
data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList))
SitesList
SitesList <- SitesList_TDP[1]
SitesList
SitesList <- as.vector(SitesList_TDP)
SitesList
data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList))
data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci))
ModCcoefs <- data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci)) %>%
pivot_wider(id_cols = region:catchment, names_from = seas, values_from = C:Sig) %>%
mutate(Sig = paste0(Sig_seas_1, "_", Sig_seas_2),
Sig2 = ifelse(Sig == "FALSE_FALSE", "no",
ifelse(Sig == "TRUE_FALSE" | Sig == "FALSE_TRUE", "one",
ifelse(Sig == "TRUE_TRUE", "both", "blah"))))
head(ModCcoefs)
# for models with catchment (unique) states
SeasDatFun.Unique <- function(MarsMod, SitesList){
# for testing
# MarsMod <- MarsSeasSiteState[[6]]
# SitesList <- as.vector(SitesList_TDP)
Modpar <- MARSSparamCIs(MarsMod, method = "hessian", alpha = 0.05, nboot = 1000)
ModCcoefs <- data.frame(coefs = as.factor(as.character(row.names(Modpar$par$U))),
C = Modpar$par$U,
Lci = Modpar$par.lowCI$U,
Uci = Modpar$par.upCI$U) %>%
filter(str_detect(coefs, "seas")) %>%
mutate(coefs = str_replace_all(coefs, "[(]",""),
coefs = str_replace_all(coefs, "[)]",""),
coefs = str_replace_all(coefs, "X.","")) %>%
separate(coefs, into = c("sites", "seas"), sep = ",") %>%
separate(sites, into = c("region", "sites", "catchment"), sep = "_") %>%
mutate(sites = fct_relevel(sites, SitesList)) %>%
mutate(Sig = SigFun(Lci, Uci)) %>%
pivot_wider(id_cols = region:catchment, names_from = seas, values_from = C:Sig) %>%
mutate(Sig = paste0(Sig_seas_1, "_", Sig_seas_2),
Sig2 = ifelse(Sig == "FALSE_FALSE", "no",
ifelse(Sig == "TRUE_FALSE" | Sig == "FALSE_TRUE", "one",
ifelse(Sig == "TRUE_TRUE", "both", "blah"))))
}
# PREPARE DATASETS
# SitesList_Not4Tdp <- levels(states$site)
SitesList_Ca <- as.vector(unique(states[states$solute == "Ca" & !is.na(states$states),]$site))
SitesList_DOC <- as.vector(unique(states[states$solute == "DOC" & !is.na(states$states),]$site))
SitesList_NH4 <- as.vector(unique(states[states$solute == "NH4N" & !is.na(states$states),]$site))
SitesList_NO3 <- as.vector( unique(states[states$solute == "NO3N" & !is.na(states$states),]$site))
SitesList_SO4 <- as.vector(unique(states[states$solute == "SO4" & !is.na(states$states),]$site))
SitesList_TDP <- as.vector(unique(states[states$solute == "TDP" & !is.na(states$states),]$site))
# for the ones with hessian issues I need to write a different function that uses
# MARSSparamCIs() with method = "parametric"
# That will take forever
Seas.Ca <- SeasDatFun.Unique(MarsSeasSiteState[[1]], SitesList_Ca)
Seas.Ca.df <- seasPlotFun.Unique(12, Seas.Ca, "Ca")
Seas.Ca.df
str(MarsSeasSiteState)
str(MarsSeasSiteState[[5]])
yr_first <- 1986
yr_last <- 2020
## load solutes data
# df <- readr::read_csv(here::here("data", "tbl_solutes_unmanaged_mon.csv"))
# df <- readr::read_csv(file.path(here::here("data"), "tbl_solutes_mon.csv"))
df <- readr::read_csv(here::here("data", "tbl_solutes_unmanaged_mon_v2.csv"))
## 2) trim data set to common time frame
df <- df %>%
filter(dec_water_yr >= yr_first & dec_water_yr <= yr_last)
## 3) convert 0 to NA following mtg and emails (ie, "no sample")
df <- df %>%
purrr::modify_at(-c(1:4), ~na_if(., 0))
## dummy covariates for season
n_months <- df$dec_water_yr %>%
unique() %>%
length()
seas_1 <- sin(2 * pi * seq(n_months) / 12)
seas_2 <- cos(2 * pi * seq(n_months) / 12)
## names of solutes
solutes <- df %>%
# select(starts_with("FWA")) %>%
select(!c(1:4)) %>%
colnames
solutes
Seas.NH4 <- SeasDatFun.Unique(MarsSeasSiteState[[3]], SitesList_NO3) #hessian issues
# library(tidyverse, lib.loc = "/home/hood.211/R_libs")
KFASurl <- "https://cran.r-project.org/src/contrib/Archive/KFAS/KFAS_1.3.6.tar.gz"
install.packages(KFASurl, repos = NULL, type = "source")
MARSurl <- "https://cran.r-project.org/src/contrib/Archive/MARSS/MARSS_3.10.12.tar.gz"
install.packages(MARSurl, repos = NULL, type = "source")
library(KFAS)
library(MARSS)
# library(doParallel, lib.loc = "/home/hood.211/R_libs")
library(doParallel)
# load MARSS model
mod_set_RW_b <- readRDS("analysis/fitted_seas_unique_states_RW_b.rds")
# Determine number of cores available.
ncores = detectCores()
## bootstrap biased RW models by site
bias_bootstrap <- mclapply(mod_set_RW_b, MARSSparamCIs, method = "parametric", nboot = 3, mc.cores = 6)
## bootstrap biased RW models by site
system.time()
## bootstrap biased RW models by site
startTime <- Sys.time()
startTime
## bootstrap biased RW models by site
startTime <- Sys.time()
bias_bootstrap <- mclapply(mod_set_RW_b, MARSSparamCIs, method = "parametric", nboot = 2, mc.cores = 6)
EndTime <- Sys.time()
EndTime-startTime
(EndTime-startTime)*500
(EndTime-startTime)*500/24
649/24
dir()
dir("Unity")
head(bias_bootstrap)
str(bias_bootstrap)
summary(bias_bootstrap)
str(bias_bootstrap[1])
389/24
summary(bias_bootstrap)
bias_bootstrap
# library(tidyverse, lib.loc = "/home/hood.211/R_libs")
KFASurl <- "https://cran.r-project.org/src/contrib/Archive/KFAS/KFAS_1.3.6.tar.gz"
mvtnormURL <- "https://cran.r-project.org/src/contrib/Archive/mvtnorm/mvtnorm_0.1-8.tar.gz"
>>>>>>> 5eb0ba0838a0a74ebcbb31eef6cb6965919e599f
